好的，我们来详细讲解在 Scala 中为 class（类）定义参数。这其实是 Scala 语言一个非常核心且优雅的特性，它将类的定义、主构造器（Primary Constructor）和字段（Fields）声明无缝地结合在了一起。

与 Java 等语言需要显式定义构造函数来接收参数不同，Scala 将其直接整合到了类的签名中。

---

### 1. 主构造器 (The Primary Constructor)

在 Scala 中，写在类名后面的参数列表 `(...)` 就是**主构造器**。这是定义一个类时最主要、最直接的构造方式。

#### a. 基本语法
最简单的形式如下：

```scala
class Person(name: String, age: Int) {
  // 类的代码体
  println(s"正在创建一个 Person 实例，名字是 $name，年龄是 $age。")

  def greet(): Unit = {
    // 注意：这里的 name 和 age 是可以访问的
    println(s"你好，我是 $name！")
  }
}

val person = new Person("张三", 30) // "正在创建一个 Person 实例..." 将被打印
person.greet() // 输出 "你好，我是 张三！"

// 但是，你不能从外部访问 person.name 或 person.age
// person.name // 编译错误！
```

**要点**:
*   `class Person(name: String, age: Int)` 这一行同时定义了类和它的主构造器。
*   主构造器的参数 `name` 和 `age` 在整个类体中都是可见的，可以像局部变量一样使用。
*   **默认情况下，主构造器的参数是 `private[this]` 的，并且它们不会成为类的字段（Fields）**。这意味着它们只在对象构造期间和类的方法内部可访问，而不能通过 `person.name` 这样的方式从外部访问。

#### b. 将构造器参数变成类的字段

这是最常见的用法。为了让构造器参数成为对象的可访问字段，你需要在参数前加上 `val` 或 `var` 关键字。

**使用 `val` (推荐，创建不可变字段)**
如果你使用 `val`，Scala 会自动为该参数创建一个**私有的、final 的字段**，以及一个**公开的 getter 方法**。

```scala
class Person(val name: String, val age: Int)

val person = new Person("李四", 25)

// 现在可以从外部访问了
println(person.name) // 输出 "李四"。这实际上是调用了 person.name() 这个 getter 方法
println(person.age)  // 输出 25

// 因为是 val，所以不能修改
// person.name = "王五" // 编译错误！
```

**使用 `var` (创建可变字段)**
如果你使用 `var`，Scala 会自动为该参数创建一个**私有的字段**，以及一个**公开的 getter 和 setter 方法**。

```scala
class Student(var name: String, var studentId: Int)

val student = new Student("王五", 1001)
println(student.name) // 输出 "王五"

// 因为是 var，所以可以修改
student.name = "赵六"
println(student.name) // 输出 "赵六"
```

#### c. 控制字段的访问权限
你也可以为主构造器参数指定访问修饰符，如 `private`, `protected`。

```scala
// name 是一个私有字段，只能在 Person 类的内部访问
// age 是一个公开的不可变字段
class Person(private val name: String, val age: Int) {
  def nameLength(): Int = {
    name.length // 在类内部可以访问 private 字段
  }
}

val p = new Person("秘密", 99)
println(p.age) // 正确
// println(p.name) // 编译错误！name 是私有的
println(p.nameLength()) // 正确，通过公有方法访问私有数据
```

**总结一下主构造器参数的四种情况**：

| 声明方式 | 结果 |
| :--- | :--- |
| `(name: String)` | 构造器参数，非字段。`private[this]` 访问级别。 |
| `(val name: String)` | 公开的、不可变的字段（只有 getter）。 |
| `(var name: String)` | 公开的、可变的字段（有 getter 和 setter）。 |
| `(private val name: String)` | 私有的、不可变的字段（只能在类内部访问）。|

---

### 2. 类体中的代码

类定义 `class ... { ... }` 中，所有不在方法定义内部的代码，都会被视为主构造器的一部分。它们会在对象创建时按顺序执行。

```scala
class Connection(val url: String) {
  println(s"准备连接到 $url...")
  
  // 可以在这里执行初始化逻辑
  private val connectedAt = java.time.Instant.now()
  
  println(s"成功连接！连接时间: $connectedAt")

  def getConnectionTime: java.time.Instant = connectedAt
}

val dbConn = new Connection("jdbc:mysql://localhost/db")
// 上面这行代码会依次打印 "准备连接..." 和 "成功连接！..."
```

---

### 3. 辅助构造器 (Auxiliary Constructors)

虽然主构造器已经能满足绝大部分需求，但有时你可能需要提供多种方式来创建对象。这时就可以使用辅助构造器。

**语法规则**:
1.  辅助构造器的名称必须是 `this`。
2.  **每一个辅助构造器的第一行代码，都必须调用同一个类中另一个已经定义的构造器**（可以是主构造器，也可以是另一个辅助构造器）。

```scala
class Person(val name: String, val age: Int) {
  
  // 辅助构造器 1: 只提供名字，年龄默认为 0
  def this(name: String) = {
    this(name, 0) // 调用主构造器
  }

  // 辅助构造器 2: 无参，名字和年龄都使用默认值
  def this() = {
    this("路人甲") // 调用上面的辅助构造器 1
    // 注意，这里不能直接调用 this("路人甲", 0)，因为它不是第一行
  }
}

val p1 = new Person("张三", 30) // 使用主构造器
val p2 = new Person("李四")      // 使用辅助构造器 1，p2.age 会是 0
val p3 = new Person()          // 使用辅助构造器 2，p3.name 是 "路人甲"，p3.age 是 0

println(s"${p2.name}, ${p2.age}") // 输出 "李四, 0"
println(s"${p3.name}, ${p3.age}") // 输出 "路人甲, 0"
```

---

### 4. 样例类 (Case Classes)

当你定义一个主要用于存放数据的类时，Scala 提供了 `case class` 这个语法糖，它极大地简化了类的定义。

```scala
case class Book(title: String, author: String)
```

上面这短短的一行 `case class` 定义，编译器会自动为你生成：

1.  **主构造器参数默认为 `public val`**。所以 `title` 和 `author` 自动成为公开的、不可变的字段。
2.  一个伴生对象（Companion Object）以及其中的 `apply` 方法，让你无需 `new` 关键字就能创建实例 (`Book("Scala编程", "Martin Odersky")`)。
3.  合理的 `toString`, `hashCode`, 和 `equals` 方法的实现。
4.  一个 `copy` 方法，用于方便地创建对象的副本并修改部分字段。
5.  对模式匹配的良好支持。

`case class` 是 Scala 中带参数定义类的最佳实践之一，尤其适用于数据模型。

### 5. 与泛型结合

带参数的类定义也可以和泛型结合使用，这在之前的讨论中已经涉及。

```scala
// 定义一个泛型类 Box，它有一个类型为 T 的构造器参数
class Box[T](val content: T) {
  def getContent: T = content
}

val intBox = new Box[Int](123)
val stringBox = new Box[String]("hello")
```
在这里，`[T]` 是类型参数，而 `(val content: T)` 是值参数，它的类型是泛型 `T`。