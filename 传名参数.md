
续fill方法

1. mycounter这个函数应该属于一个object或者class。那么var counter是一个什么类型的变量决定了会一直是1还是累加？很奇怪的是，第一个例子中，counter一直是1，说明counter一直在被初始化，一直在创建，这太怪异了

2. 这个传名参数函数在传递的时候就掉用了一次，导致counter从2开始计数？为什么会先掉用一次？

3. 所以说传名参数和常规参数的区别在于”谁在调用函数“？常规参数由一个未知的（我不知道）来调用函数，然后把返回值传递给他，传名参数在函数内部调用函数。
但是还是那个问题，counter并不是mycounter内部的static变量，也不会累计啊？












您提出的问题非常好，说明您在深入思考这个概念，而不仅仅是看表面。这些疑问都是理解传名参数（By-Name Parameter）的关键，让我们逐一拆解。

---

### 解答疑问 1：对于常规参数，为什么 `counter` 一直是 1？

您的直觉是对的，但这并不是因为 `counter` 被反复初始化了，而是因为**对于常规（传值）参数，`myExpression()` 这个函数从始至终只被执行了一次**。

让我们把下面这行代码的执行过程放慢：

```scala
val result_byValue = Seq.fill(3)(myExpression())
```

Scala 引擎在执行 `Seq.fill` 这个方法**之前**，必须先准备好所有要传递给它的参数。

1.  **准备第一个参数 `n`：** 这个很简单，就是整数 `3`。
2.  **准备第二个参数 `elem`：** 参数是 `myExpression()`。这是一个函数调用，所以 Scala 必须**立即执行它**来得到结果。
    *   `myExpression()` 被调用。
    *   `counter` 从 `0` 变为 `1`。
    *   控制台打印出 `"Expression evaluated! Counter is now 1"`。
    *   `myExpression()` 返回 `counter` 的当前值，也就是整数 `1`。
3.  **调用 `Seq.fill`：** 现在所有参数都准备好了。Scala 实际执行的调用可以看作是：
    ```scala
    Seq.fill(3)(1) // myExpression() 已经被它的返回值 1 替代了
    ```
4.  **`fill` 的内部工作：** `fill` 方法拿到的是数字 `3` 和数字 `1`。它的任务就是创建一个包含 3 个元素的序列，每个元素都用它收到的值 `1` 来填充。
5.  **最终结果：** `result_byValue` 因此是 `Seq(1, 1, 1)`。

**核心结论：** 对于传值参数，参数表达式在传递给函数**之前**就已经被计算成了一个**最终的值**。函数本身只知道这个值，完全不知道这个值是怎么来的。所以 `myExpression()` 只运行了一次，`counter` 自然也只增加了一次。

---

### 解答疑问 2：传名参数为什么从 2 开始计数？

这是一个非常敏锐的观察！原因并不在于传名参数会“预先调用一次”，而在于您提供的示例代码中，**两个测试是连续执行的，它们共享了同一个 `counter` 变量**。

让我们梳理一下整个代码的执行顺序：

1.  `var counter = 0`：在所有测试开始前，`counter` 被初始化为 `0`。
2.  **执行传值测试 (`result_byValue`)**：
    *   如上所述，`myExpression()` 被调用**一次**。
    *   `counter` 的值从 `0` 变成了 `1`。
    *   `result_byValue` 被赋值为 `Seq(1, 1, 1)`。
    *   **此时，第一个测试结束，`counter` 这个变量的值已经是 `1` 了。它没有被重置。**
3.  **执行传名测试 (`result_byName`)**：
    *   `val result_byName = Seq.fill(3)(myExpression())` 开始执行。
    *   因为 `elem` 是传名参数 (`=> A`)，所以 `myExpression()` **不会**在这里被立即执行。Scala 只是把“如何执行 `myExpression()`”这个**指令**或**代码块**传递给了 `fill` 方法。
    *   `fill` 方法内部需要创建第一个元素。它执行了一次收到的“指令”，也就是调用 `myExpression()`。
        *   `counter` 从 `1` 变为 `2`。
        *   打印 `"Expression evaluated! Counter is now 2"`。
        *   返回 `2` 作为序列的第一个元素。
    *   `fill` 方法需要创建第二个元素。它**再次**执行那个“指令”。
        *   `counter` 从 `2` 变为 `3`。
        *   打印 `"Expression evaluated! Counter is now 3"`。
        *   返回 `3` 作为序列的第二个元素。
    *   `fill` 方法需要创建第三个元素。它**第三次**执行那个“指令”。
        *   `counter` 从 `3` 变为 `4`。
        *   打印 `"Expression evaluated! Counter is now 4"`。
        *   返回 `4` 作为序列的第三个元素。
4.  **最终结果：** `result_byName` 是 `Seq(2, 3, 4)`。

所以，计数从 2 开始，完全是因为 `counter` 变量在传值测试中已经被修改过一次了。如果单独只运行传名参数那部分代码，结果会是 `Seq(1, 2, 3)`。

---

### 解答疑问 3：区别在于“谁在调用函数”以及 `counter` 的累加问题

您的这个想法非常接近核心！我们可以把它提炼得更精确一些：

**区别在于“表达式在何时、何地被求值（计算）”。**

*   **常规参数（传值，By-Value）**
    *   **求值时机：** 在函数被调用**之前**。
    *   **求值方：** **调用者（Caller）**。调用者负责算好参数的值，然后把这个最终的值塞给函数。
    *   **函数得到什么：** 一个具体的、已经计算好的**值**（比如 `1`）。

*   **传名参数（By-Name）**
    *   **求值时机：** 在函数**内部**，每当这个参数被**使用**的时候。
    *   **求值方：** **被调用者（Callee）**，也就是函数本身。
    *   **函数得到什么：** 一个**代码块**或者说一个“承诺”，它承诺了“如果你需要一个值，就运行我这段代码”。`fill` 方法每次需要新元素时，就兑现一次这个“承诺”。

**关于 `counter` 为何能累加（无需 `static`）：**

这是因为 `var counter` 和 `def myExpression` 都定义在同一个作用域内（比如一个 `object` 或 `class` 的方法体里）。`myExpression` 方法形成了一个**闭包（Closure）**，它捕获（captures）了其定义时所在作用域的变量 `counter`。

*   **闭包**：可以简单理解为一个函数和它所引用的外部变量的组合。
*   所以，每次调用 `myExpression` 时，它访问和修改的都是同一个、外部的那个 `counter` 变量。它不需要是 `static` 的。在 Scala 中，只要变量在作用域内可见，内部函数就可以访问和修改它。这与 `static` 的概念不同，后者通常与类本身关联，而不是实例或作用域。

希望这个分解说明能彻底解决您的疑问！传名参数是 Scala 一个非常强大和富有表达力的特性，尤其在构建惰性计算（lazy evaluation）和领域特定语言（DSL）时非常有用。