A common set of higher-order functions you'll use are `scanLeft`/`scanRight`, `reduceLeft`/`reduceRight`, and `foldLeft`/`foldRight`. It's important to understand how each one works and when to use them. The default directions for `scan`, `reduce`, and `fold` are left, though this is not guaranteed for all cases.


这三个方法 `reduce`、`fold` 和 `scan` 都是 Scala 集合框架中处理元素的强大工具。它们的核心思想都是：**通过迭代，将一个二元操作符应用于集合元素**。

它们的区别主要体现在：**是否有初始值**、**返回结果的形式**以及**是否支持类型变换**。

---

### 1. `reduce` (归约)
**关键词：最简单、无初始值、同类型**

*   **定义**：利用集合自身的第一个元素作为起点，逐步将后续元素合并。
*   **初始值**：**不需要**。直接拿列表第一个元素当初始值。
*   **返回值**：最终的**单个计算结果**。
*   **类型约束**：返回值类型必须是集合元素类型的**超类**（通常就是同类型）。例如 `List[Int]` 只能 reduce 出 `Int`。
*   **风险**：如果集合为空，抛出 `UnsupportedOperationException` 异常。

```scala
val list = List(1, 2, 3, 4)
// 过程：((1 + 2) + 3) + 4 = 10
val res = list.reduce((a, b) => a + b) 
// 结果: 10
```

---

### 2. `fold` (折叠)
**关键词：有初始值、更灵活、类型可变**

*   **定义**：提供一个**初始值（Seed）**，从这个初始值开始与集合元素进行合并。
*   **初始值**：**需要显式提供**（柯里化的第一个参数列表）。
*   **返回值**：最终的**单个计算结果**。
*   **类型约束**：**非常灵活**。累加器的类型（返回值类型）可以与集合元素的类型完全不同。
*   **安全性**：如果集合为空，直接返回初始值，**不会报错**。

```scala
val list = List(1, 2, 3, 4)

// 示例1：同类型累加。初始值 10
// 过程：((((10 + 1) + 2) + 3) + 4) = 20
val res1 = list.fold(10)((a, b) => a + b) 

// 示例2：类型变换（Int -> String）
// 初始值是空字符串 ""，把数字拼接到字符串上
val res2 = list.foldLeft("")((acc, curr) => acc + curr.toString)
// 结果: "1234" (类型是 String)
```
*注：Scala 中通常使用 `foldLeft` 或 `foldRight` 来确定遍历方向。直接用 `fold` 在并行集合中顺序是不确定的，但在 List 中通常等同于 foldLeft。*

---

### 3. `scan` (扫描)
**关键词：保留过程、有初始值、返回集合**

*   **定义**：和 `fold` 的逻辑一模一样，但是它**不丢弃中间结果**。它把每一步的累加状态都保存下来。
*   **初始值**：**需要显式提供**。
*   **返回值**：一个**新的集合**。包含：`[初始值, 第1步结果, 第2步结果, ..., 最终结果]`。
*   **特点**：返回集合的长度总是比原集合长度 **+1**。

```scala
val list = List(1, 2, 3, 4)

// 初始值 0，操作是累加
val res = list.scan(0)((a, b) => a + b)

// 过程解析：
// 0 (初始值)
// 0 + 1 = 1
// 1 + 2 = 3
// 3 + 3 = 6
// 6 + 4 = 10

// 结果 List(0, 1, 3, 6, 10)
```

---

### 总结对比表

| 特性 | reduce | fold (foldLeft/Right) | scan (scanLeft/Right) |
| :--- | :--- | :--- | :--- |
| **初始值** | 无 (使用第一个元素) | **有** (显式提供) | **有** (显式提供) |
| **返回值** | 单个值 | 单个值 | **集合** (保存了历史轨迹) |
| **类型灵活性** | 弱 (必须同类型/超类) | **强** (结果类型可变) | **强** (结果类型可变) |
| **空集合处理** | **报错** (Exception) | 安全 (返回初始值) | 安全 (返回只含初始值的集合) |
| **典型用途** | 简单的同类聚合 (如求和) | 复杂的聚合、类型转换 | 计算前缀和、运行轨迹、累积统计 |

### 记忆口诀

1.  **Reduce**：就是“缩减”，自身相残，没初始值，最后剩一个。
2.  **Fold**：就是“打包”，自带背包（初始值），一路捡东西，最后剩一个包。
3.  **Scan**：就是“直播版的 Fold”，自带背包，不仅要结果，还要把每一步的变化都录下来发给你。

### 补充：关于 `Left` 和 `Right`

这三个方法通常都有 `Left` 和 `Right` 两个版本（例如 `foldLeft`, `foldRight`）：
*   `...Left`：从左向右遍历（通常是首选，符合直觉，且 `foldLeft` 是尾递归优化的）。
*   `...Right`：从右向左遍历。

**对于 `List` 来说，除非有特殊需求，通常推荐默认使用 `foldLeft`。**